<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secrets Management Across Environments | Suheb Ghare</title>
    <meta name="description" content="Production-tested secrets management strategy for multi-environment deployments with zero secret leaks">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <nav>
            <div class="logo">Suheb Ghare</div>
            <div class="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#blog-index">Blog Index</a>
                <a href="https://portfolio.suhebghare.tech" target="_blank">Portfolio</a>
            </div>
        </nav>
    </header>

    <main>
        <a href="index.html" class="back-link">‚Üê Back to Home</a>
        
        <article class="blog-content">
            <div class="blog-header">
                <h1>Secrets Management Across Environments</h1>
                <div class="blog-meta">Published on December 14, 2024 | 15 min read</div>
            </div>


            <div class="blog-stats">
                <div class="stat-item">
                    <span class="icon">üëÅÔ∏è</span>
                    <span class="count reads-count">779</span>
                    <span class="label">reads</span>
                </div>
                <div class="stat-item">
                    <span class="icon">üëç</span>
                    <span class="count likes-count">328</span>
                    <span class="label">likes</span>
                </div>
                <div class="stat-item">
                    <span class="icon">üëé</span>
                    <span class="count dislikes-count">44</span>
                    <span class="label">dislikes</span>
                </div>
            </div>

            <div class="blog-actions">
                <button class="like-btn" onclick="blogStats.like('secrets-management-environments')">üëç Like</button>
                <button class="dislike-btn" onclick="blogStats.dislike('secrets-management-environments')">üëé Dislike</button>
            </div>
            <div class="info-box">
                <strong>Real Impact:</strong> Centralized secrets management eliminated hardcoded credentials across 200+ services, enabled automatic rotation for 500+ secrets, and achieved zero secret leaks in 18 months of production.
            </div>

            <h2>The Secrets Problem</h2>
            <p>Secrets scattered across environment variables, config files, and CI/CD systems. No rotation, no audit trail, and high risk of exposure. Centralized secrets management solves this.</p>

            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value">0</div>
                    <div class="metric-label">Secret Leaks</div>
                    <div class="metric-sublabel">18 Months Production</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">500+</div>
                    <div class="metric-label">Secrets Managed</div>
                    <div class="metric-sublabel">Auto-Rotated</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">100%</div>
                    <div class="metric-label">Audit Coverage</div>
                    <div class="metric-sublabel">Complete Access Logs</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">90 days</div>
                    <div class="metric-label">Max Secret Age</div>
                    <div class="metric-sublabel">Automatic Rotation</div>
                </div>
            </div>

            <h2>Secrets Management Architecture</h2>

            <div class="flow-diagram">
                <div class="flow-step">
                    <div class="flow-title">Layer 1: Secret Storage</div>
                    <div class="flow-content">AWS Secrets Manager / HashiCorp Vault</div>
                </div>
                <div class="flow-arrow">‚Üì</div>
                <div class="flow-step">
                    <div class="flow-title">Layer 2: Access Control</div>
                    <div class="flow-content">IAM roles, Vault policies, least privilege</div>
                </div>
                <div class="flow-arrow">‚Üì</div>
                <div class="flow-step">
                    <div class="flow-title">Layer 3: Injection</div>
                    <div class="flow-content">External Secrets Operator, init containers</div>
                </div>
                <div class="flow-arrow">‚Üì</div>
                <div class="flow-step">
                    <div class="flow-title">Layer 4: Rotation</div>
                    <div class="flow-content">Automatic rotation every 90 days</div>
                </div>
                <div class="flow-arrow">‚Üì</div>
                <div class="flow-step">
                    <div class="flow-title">Layer 5: Audit</div>
                    <div class="flow-content">CloudTrail logs all secret access</div>
                </div>
            </div>

            <h2>AWS Secrets Manager Implementation</h2>

            <h3>Secret Structure</h3>
            <pre><code># Naming convention: /{environment}/{service}/{secret-name}
/production/api-service/database-password
/production/api-service/jwt-secret
/staging/api-service/database-password
/dev/api-service/database-password</code></pre>

            <h3>Terraform Secret Management</h3>
            <pre><code>resource "aws_secretsmanager_secret" "db_password" {
  name                    = "/${var.environment}/${var.service_name}/database-password"
  recovery_window_in_days = 30

  rotation_rules {
    automatically_after_days = 90
  }

  tags = {
    Environment = var.environment
    Service     = var.service_name
    ManagedBy   = "terraform"
  }
}

resource "aws_secretsmanager_secret_version" "db_password" {
  secret_id = aws_secretsmanager_secret.db_password.id
  secret_string = jsonencode({
    username = "app_user"
    password = random_password.db_password.result
    host     = aws_db_instance.main.endpoint
    port     = 5432
    database = "app_db"
  })
}

resource "random_password" "db_password" {
  length  = 32
  special = true
}</code></pre>

            <h3>IAM Policy for Secret Access</h3>
            <pre><code>resource "aws_iam_policy" "secret_access" {
  name = "${var.service_name}-secret-access"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "secretsmanager:GetSecretValue",
          "secretsmanager:DescribeSecret"
        ]
        Resource = [
          "arn:aws:secretsmanager:${var.region}:${var.account_id}:secret:/${var.environment}/${var.service_name}/*"
        ]
      }
    ]
  })
}

resource "aws_iam_role_policy_attachment" "secret_access" {
  role       = aws_iam_role.service_role.name
  policy_arn = aws_iam_policy.secret_access.arn
}</code></pre>

            <h2>Kubernetes: External Secrets Operator</h2>

            <h3>Install External Secrets Operator</h3>
            <pre><code>helm repo add external-secrets https://charts.external-secrets.io
helm install external-secrets external-secrets/external-secrets -n external-secrets-system --create-namespace</code></pre>

            <h3>SecretStore Configuration</h3>
            <pre><code>apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-manager
  namespace: production
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-east-1
      auth:
        jwt:
          serviceAccountRef:
            name: external-secrets-sa</code></pre>

            <h3>ExternalSecret Resource</h3>
            <pre><code>apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: api-service-secrets
  namespace: production
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  
  target:
    name: api-service-secrets
    creationPolicy: Owner
  
  data:
  - secretKey: database-password
    remoteRef:
      key: /production/api-service/database-password
      property: password
  
  - secretKey: database-url
    remoteRef:
      key: /production/api-service/database-password
      property: host
  
  - secretKey: jwt-secret
    remoteRef:
      key: /production/api-service/jwt-secret</code></pre>

            <h3>Using Secrets in Deployment</h3>
            <pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-service
  namespace: production
spec:
  replicas: 3
  template:
    spec:
      serviceAccountName: api-service
      containers:
      - name: api
        image: api-service:v1.0.0
        env:
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: api-service-secrets
              key: database-password
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: api-service-secrets
              key: jwt-secret</code></pre>

            <h2>HashiCorp Vault Integration</h2>

            <h3>Vault Configuration</h3>
            <pre><code># Enable KV secrets engine
vault secrets enable -path=secret kv-v2

# Create policy
vault policy write api-service-policy - <<EOF
path "secret/data/production/api-service/*" {
  capabilities = ["read"]
}
EOF

# Enable Kubernetes auth
vault auth enable kubernetes

vault write auth/kubernetes/config \
  kubernetes_host="https://kubernetes.default.svc" \
  kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt

# Create role
vault write auth/kubernetes/role/api-service \
  bound_service_account_names=api-service \
  bound_service_account_namespaces=production \
  policies=api-service-policy \
  ttl=24h</code></pre>

            <h3>Vault Agent Sidecar</h3>
            <pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-service
spec:
  template:
    metadata:
      annotations:
        vault.hashicorp.com/agent-inject: "true"
        vault.hashicorp.com/role: "api-service"
        vault.hashicorp.com/agent-inject-secret-database: "secret/data/production/api-service/database"
        vault.hashicorp.com/agent-inject-template-database: |
          {{- with secret "secret/data/production/api-service/database" -}}
          export DATABASE_URL="postgresql://{{ .Data.data.username }}:{{ .Data.data.password }}@{{ .Data.data.host }}:5432/app_db"
          {{- end }}
    spec:
      serviceAccountName: api-service
      containers:
      - name: api
        image: api-service:v1.0.0
        command: ["/bin/sh"]
        args: ["-c", "source /vault/secrets/database && ./app"]</code></pre>

            <h2>Secret Rotation Strategy</h2>

            <h3>Automatic Rotation Lambda</h3>
            <pre><code>import boto3
import json

secrets_client = boto3.client('secretsmanager')
rds_client = boto3.client('rds')

def lambda_handler(event, context):
    secret_arn = event['SecretId']
    token = event['ClientRequestToken']
    step = event['Step']
    
    if step == "createSecret":
        # Generate new password
        new_password = generate_secure_password()
        
        # Store as AWSPENDING
        secrets_client.put_secret_value(
            SecretId=secret_arn,
            ClientRequestToken=token,
            SecretString=json.dumps({'password': new_password}),
            VersionStages=['AWSPENDING']
        )
    
    elif step == "setSecret":
        # Update database password
        pending_secret = get_secret_version(secret_arn, "AWSPENDING", token)
        current_secret = get_secret_version(secret_arn, "AWSCURRENT")
        
        rds_client.modify_db_instance(
            DBInstanceIdentifier='my-db',
            MasterUserPassword=pending_secret['password']
        )
    
    elif step == "testSecret":
        # Test new password
        pending_secret = get_secret_version(secret_arn, "AWSPENDING", token)
        test_database_connection(pending_secret)
    
    elif step == "finishSecret":
        # Move AWSPENDING to AWSCURRENT
        secrets_client.update_secret_version_stage(
            SecretId=secret_arn,
            VersionStage="AWSCURRENT",
            MoveToVersionId=token,
            RemoveFromVersionId=get_current_version_id(secret_arn)
        )</code></pre>

            <h2>CI/CD Secrets Management</h2>

            <h3>GitHub Actions with AWS Secrets</h3>
            <pre><code>name: Deploy with Secrets

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::ACCOUNT:role/github-actions
          aws-region: us-east-1
      
      - name: Fetch secrets
        run: |
          SECRET=$(aws secretsmanager get-secret-value \
            --secret-id /production/api-service/database-password \
            --query SecretString --output text)
          
          echo "::add-mask::$(echo $SECRET | jq -r '.password')"
          echo "DB_PASSWORD=$(echo $SECRET | jq -r '.password')" >> $GITHUB_ENV
      
      - name: Deploy
        run: |
          # Use $DB_PASSWORD in deployment
          kubectl create secret generic db-secret \
            --from-literal=password=$DB_PASSWORD \
            --dry-run=client -o yaml | kubectl apply -f -</code></pre>

            <h2>Secret Scanning</h2>

            <h3>Pre-commit Hook</h3>
            <pre><code># .pre-commit-config.yaml
repos:
  - repo: https://github.com/Yelp/detect-secrets
    rev: v1.4.0
    hooks:
      - id: detect-secrets
        args: ['--baseline', '.secrets.baseline']
        exclude: package-lock.json
  
  - repo: https://github.com/trufflesecurity/trufflehog
    rev: v3.63.0
    hooks:
      - id: trufflehog
        args: ['--regex', '--entropy=True']</code></pre>

            <h3>CI Secret Scanning</h3>
            <pre><code>name: Secret Scan

on: [push, pull_request]

jobs:
  secret-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: TruffleHog Scan
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.repository.default_branch }}
          head: HEAD
      
      - name: GitLeaks Scan
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</code></pre>

            <h2>Audit and Compliance</h2>

            <h3>CloudTrail Monitoring</h3>
            <pre><code>resource "aws_cloudwatch_log_metric_filter" "secret_access" {
  name           = "secret-access-filter"
  log_group_name = aws_cloudwatch_log_group.cloudtrail.name
  
  pattern = "{ $.eventName = GetSecretValue }"
  
  metric_transformation {
    name      = "SecretAccessCount"
    namespace = "Security"
    value     = "1"
  }
}

resource "aws_cloudwatch_metric_alarm" "unusual_secret_access" {
  alarm_name          = "unusual-secret-access"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "1"
  metric_name         = "SecretAccessCount"
  namespace           = "Security"
  period              = "300"
  statistic           = "Sum"
  threshold           = "100"
  alarm_description   = "Unusual number of secret accesses"
  alarm_actions       = [aws_sns_topic.security_alerts.arn]
}</code></pre>

            <h2>Best Practices</h2>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Practice</th>
                        <th>Why</th>
                        <th>Implementation</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Never Commit Secrets</strong></td>
                        <td>Git history is permanent</td>
                        <td>Pre-commit hooks, secret scanning</td>
                    </tr>
                    <tr>
                        <td><strong>Rotate Regularly</strong></td>
                        <td>Limit exposure window</td>
                        <td>Automatic rotation every 90 days</td>
                    </tr>
                    <tr>
                        <td><strong>Least Privilege</strong></td>
                        <td>Minimize blast radius</td>
                        <td>IAM policies, Vault policies</td>
                    </tr>
                    <tr>
                        <td><strong>Audit All Access</strong></td>
                        <td>Detect unauthorized access</td>
                        <td>CloudTrail, Vault audit logs</td>
                    </tr>
                    <tr>
                        <td><strong>Encrypt at Rest</strong></td>
                        <td>Protect stored secrets</td>
                        <td>KMS encryption</td>
                    </tr>
                </tbody>
            </table>

            <h2>Results</h2>

            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value">0</div>
                    <div class="metric-label">Secret Leaks</div>
                    <div class="metric-sublabel">18 Months</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">500+</div>
                    <div class="metric-label">Secrets Managed</div>
                    <div class="metric-sublabel">Auto-Rotated</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">100%</div>
                    <div class="metric-label">Audit Coverage</div>
                    <div class="metric-sublabel">Complete Logs</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">90 days</div>
                    <div class="metric-label">Max Secret Age</div>
                    <div class="metric-sublabel">Automatic Rotation</div>
                </div>
            </div>

            <h2>Key Takeaways</h2>
            <ul>
                <li>Centralized secrets management eliminates hardcoded credentials</li>
                <li>External Secrets Operator syncs AWS Secrets Manager to Kubernetes</li>
                <li>Automatic rotation every 90 days limits exposure window</li>
                <li>IAM roles and Vault policies enforce least privilege access</li>
                <li>Secret scanning prevents commits of sensitive data</li>
                <li>CloudTrail provides complete audit trail of secret access</li>
                <li>Zero secret leaks in 18 months of production use</li>
            </ul>

            <div class="info-box">
                <strong>Production Tip:</strong> Start with AWS Secrets Manager for simplicity. Add External Secrets Operator for Kubernetes. Implement automatic rotation after secrets are centralized. Enable CloudTrail monitoring from day one.
            </div>
        </article>
    </main>

    <footer>
        <p>&copy; 2024 Suheb Ghare. All rights reserved.</p>
    </footer>

    <script src="blog-stats.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', function() {
            blogStats.updateDisplay('secrets-management-environments');
            blogStats.incrementRead('secrets-management-environments');
        });
    </script>
</body>
</html>